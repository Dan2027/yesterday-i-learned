- [Decorators can go inside a method declaration](https://github.com/mapbox/mapbox-navigation-android/pull/1733/files#diff-dcd7ab28ce2157b472a650814946d1e39a8ce0caf1ec851302a28e0dd60a7232R511).
- The name "Kotlin" came from [Kotlin Island](https://en.wikipedia.org/wiki/Kotlin_Island), not an anagram of anything, such as _Kinton_.
- Kotlin was _invented_ by JetBrains, the people who made Android Studio. It is impossible not to get first-class support for it.
- There is a repl (called `kotlinc-jvm`), but it's hella slow. [Install with instructions.](https://kotlinlang.org/docs/tutorials/command-line.html)
- [Kotlin has longer compilation times compared to Java](https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d), with the exception of incremental builds, which may match Java's compile time. So, while developer efficiency goes up (with less boilerplate code), machine efficiency goes down. A fair tradeoff.
- [`f() ?: g()`](https://en.wikipedia.org/wiki/Elvis_operator) is `f() ? f() : g()`, except `f` doesn't get called twice.
- Apparently, one of Kotlin's big selling points is [null safety](https://kotlinlang.org/docs/reference/null-safety.html), where normal variables can never point to a `null`. But [`null` is still a thing](https://kotlinlang.org/docs/reference/null-safety.html) and can be explicitly checked and/or allowed (by adding `?` after the variable name declaration). [Saying "no more `NullPointerException`" is **not** true](https://clearbridgemobile.com/java-vs-kotlin-which-is-the-better-option-for-android-app-development/).
- In constrast, instead of using `?` to make something nullable, you can use [`!!`](https://kotlinlang.org/docs/reference/null-safety.html#the--operator) to make sure something absolutely isn't null, usually when you run java code, which has no null safety. (Yes, it then crashes if something is null.)
- A [data class](https://kotlinlang.org/docs/reference/data-classes.html) (the Java equivalent would be a generic class with getters, setters, `hashCode()`, and `toString()`?) is built-in, using `data class ClassName(*val fields)`. All it does is contain data.
- A nullable variable cannot have its methods called unless its null-ness is checked (literally, in your code, write `!= null`).
- **Classes can have multiple constructors**, but only one unique [primary constructor](https://kotlinlang.org/docs/reference/classes.html#constructors). The primary one is just the stuff you put inside `class ClassName constructor(*args)`. All other constructors need to reference the primary constructor one way or the other.
- `init` blocks are pre-constructor methods. A class can have any number of these, interleved with [pretty much anything you like](https://kotlinlang.org/docs/reference/classes.html#constructors), including statements. _And then_ constructors are called.
- Kotlin does not have a `new` keyword.
- The default base class is `Any`. All classes implicitly inherit from `Any`.
- "Overridable" methods are called "open functions", and must be called that to be overridden (e.g. `open fun foo() { ... }`). Overridden methods must also call themselves overrides (e.g. `override fun foo() { ... })`. Like Java, any function that is not open can have `final` in front of it to ensure it is never overridden.
- Classes _themselves_ must also be marked as open/override and final with the [`open class`](https://kotlinlang.org/docs/tutorials/kotlin-for-py/inheritance.html) syntax.
- Properties (i.e. attributes) must also be marked as open/override and final.
- [A file can contain multiple classes.](https://kotlinlang.org/docs/reference/coding-conventions.html) See also: coding conventions.
- So Kotlin classes ("KClass") are [not](https://kotlinlang.org/docs/reference/reflection.html) Java classes. To get the reference to a class, use `ClassName::class` (a KClass) instead of just `ClassName`. To get the Java class equivalent, use `SomeJavaClass::class.java` instead.
- Method calls can seemingly contain bodies for no reason. See this example: `assert(widget is GoodWidget) { "Bad widget: ${widget::class.qualifiedName}" }`
- A lambda's parameters are declared [**inside** its braces](https://medium.com/@dbottillo/kotlin-by-examples-methods-and-lambdas-25aef7544365), so `onClick({ view -> doSomething() })` is a lambda. If you hate that, you're in luck, because if you don't need any arguments, you can skip `view ->` and make it look like something sane, i.e. `onClick({ doSomething() })`.
- For some reason, instead of stopping there, kotlin enjoys having function arguments outside the parents _iff it is the last argument of the function call_, so you get `onClick() { doSomething() }` instead. But wait, there's fucking more. If the function call takes just one thing, and that one thing is a function, then you have to skip the parentheses anyway, resulting in the final form: `onClick { doSomething() }`.
- But if you want to pass in a named function? Fuck you, use parens: `onClick(doSomething)`.
- The `with(obj, func)` built-in (bearing in mind the last argument is a function, so the lambda stuff above syntactically applies) is the same as [what you used to use in VB6](https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/with-end-with-statement): unresolved names are to be found in the object's attributes.
- Comment styles are the same as the majority of others (`//`, `/* */`).
- Built-in keywords can be [hard or soft](https://kotlinlang.org/docs/reference/keyword-reference.html). You cannot change hard ones, like `if`/`else`, `class`, and `fun`. You _can_ change soft keywords like `file`, `get`, and `set`.
- ALL functions with blocks, i.e. not a one-liner, need an explicit `return` statement if they have a return type.
- Because you need to declare parameter types now, the type of a lambda is usually `() -> Unit`, unless they take arguments. That's because **`Unit` maps to a java `void`** by default. `() -> Unit` means an anoymous function that returns nothing.
- You can also use `() -> Any?` for "function type", for functions that can literally return anything.
- The function that accepts a lambda specifies what types the lambda needs to take. The lambdas themselves do not need to (but can) do that.
- ["In most cases, Kotlin follows the Java coding conventions"](https://kotlinlang.org/docs/reference/coding-conventions.html#formatting), where the [official Oracle Java convention](https://www.oracle.com/technetwork/java/codeconventions-150003.pdf) says "Avoid lines longer than 80 characters ... Examples for use in documentation should have a shorter line lengthâ€”generally nomore than 70 characters."
- A one-liner lambda that takes a single argument can be written as something like `it % 2` instead of `num -> num % 2`.
- Java's "anything of some type" syntax, `<?>`, might have been replaced by `<*>`.
- An array of strings is [`Array<String>`](https://stackoverflow.com/a/44239940/1558430). An array of ints is either [`IntArray`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/index.html), because it's a modern language and is very consistent, or `Array<Int>`, which is not proven to work.
- A google map won't load until [you add the key](https://www.raywenderlich.com/230-introduction-to-google-maps-api-for-android-with-kotlin).
- unlike Java, functions can be top-level. It has however no static methods. The "static method" equivalent would be setting up a [`companion object`](https://android.jlelse.eu/daily-kotlin-static-methods-9330552cde8a). Any method you put in that object (similar syntax to how to put methods in ES6 classes) will be effectively static.
- [Coroutines are not strictly-speaking threads](https://github.com/Kotlin/kotlinx.coroutines), but in some cases they are implemented as such.
- The built-in [`arrayOf(...args)`](https://stackoverflow.com/questions/44239869/whats-the-kotlin-equivalent-of-javas-string) gives you an array of those args. You don't need to specify the types. If you want to have an empty array, guess what? `emptyArray()`
- `getApplicationContext()` becomes `applicationContext` in Kotlin, even though it is a "global".
- Double quotes are still strings. Single quotes are still chars.
- Then `when` built-in, actually just `switch-case`, requires you to specify `->` in front of each case's code block, i.e. `1 -> { ... }`.
- `/* Block comments /* can */ be nested. */`
- Strings can have `"substitutions like $this"` (where `val this = "this"`).
- It is possible to suffix something to a class, including seemingly built-in ones like `Number`, and instantly create a new attribute. [klock](https://korlibs.soywiz.com/klock/#unix-timestamp) does it like so: `DateTime.now() + 10.seconds` (where `seconds` is an attribute on `Number` now.)
- [Nested `this`](https://kotlinlang.org/docs/reference/this-expressions.html) can be a problem sometimes. JS tackles this by allowing you to assign `this` to some variable. Kotlin allows you to refer to `this` with `this@OuterClassName`. This works at any level.
- [`vararg`](https://www.callicoder.com/kotlin-functions/) (`*args` equivalent) can only be used once in a function signature, and everything after the `vararg` must be named (`**kwargs` equivalent).
- The spread operator is *still* `*`.
- Kotlin occasionally uses something called the [infix notation](https://en.wikipedia.org/wiki/Infix_notation). Method calls like `a.to(b).as(c)` can simply be written as [`a to b as c`](https://www.callicoder.com/kotlin-infix-notation/)... but only if you mark the function as `infix`, i.e. `infix fun to(b: Int)`, and [the function **must** accept exactly one parameter](https://kotlinlang.org/docs/reference/functions.html#infix-notation). [Example](sources/0009.kt). tl;dr: for reduce overhead on readability, just don't use `infix`.
* [`suspend fun`](https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html) declares an async function, just not using the `async` keyword. To use a `suspend fun`, you call `val foo = async { doStuff() }`, and then say `foo.await()` to get the result.
* `async { foo() }` can also be [`async(start = CoroutineStart.LAZY) { foo() }`](https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html#lazily-started-async), if you want the task to start only when the result is needed.
* Return statements can have qualified scopes too: [`return@foo ...`](https://stackoverflow.com/questions/45348820/using-return-inside-a-lambda). However, [it is impossible to return a function from inside a async method](https://stackoverflow.com/a/45732988/1558430).
* [Primitive function arguments are not mutable](https://stackoverflow.com/questions/44109098/how-do-i-make-method-param-mutable-in-kotlin). Make another variable.
* `{ ... }` is simultaneously a "lambda", as well as a ["block of code"](https://kotlinlang.org/docs/reference/scope-functions.html). There seems to be [no difference between the two](https://kotlinlang.org/docs/reference/lambdas.html#instantiating-a-function-type), except you don't hear about the docs talking about code blocks with parameters.
* So how do you build a dictionary then? Turns out you don't really do that in any meaningful way [yet](https://stackoverflow.com/a/50322520/1558430). You can [make a `hashMapOf` something](https://stackoverflow.com/a/42161067/1558430) but the `"a" to "b"` syntax relies on infix function calls of `to`.
* The `{}` in things like `setListener { foo() }` may seem kind of pointless, and it is in other languages, but that's because the `{}` helps with type conversion. You can't just `setListener(foo)`.
* Private members/methods cannot be accessed by a subclass, even if it itself inherits the method. To access it, use `protected`.
- String interpolation is done with `"this $syntax"` or `"that ${syntax(its, up, to, you)}"`.
- All functions return `: Unit` (which is void) by default; there is no need to specify it. You can also omit the return type when the compiler can infer it, which is most of the time.
- Triple-quoted strings are raw strings (not docstrings). **Raw strings don't support escaping but support interpolation** (wtf?), so if you want a `$` sign inside your raw string literal, guess what you'll have to do: `"""That sucks a${"$$"}"""`
- [`trimMargin()` and `trimMargin('|')`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html) (optional margin character) lets you trim off each line of the string, and return one where it starts after the margin character.
- I don't think there is a difference between [`arrayOf<Int>()` and `emptyArray<Int>()`](https://stackoverflow.com/q/29743160/1558430). Both throw `ArrayIndexOutOfBoundsException` when you try to access an element. But there is also an [`IntArray` class](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int-array/), and its helper function [`intArrayOf()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/int-array-of.html). [An `IntArray(size)` is equivalent java's `int[size]`](https://stackoverflow.com/a/35253626/1558430), which (if I may take an educated guess) is a primitive array, storing literal values insteaad of objects, that is faster than the `Array<T>` or something. A good rule of thumb is to use `Array` unless a function explicitly asks for an `IntArray` (or of any other primitive type). You may encounter primitive arrays of type: `booleanArrayOf` (`boolean[]`), `byteArrayOf` (`byte[]`), `charArrayOf` (`char[]`), `doubleArrayOf` (`double[]`), `floatArrayOf` (`float[]`), `intArrayOf` (`int[]`), `longArrayOf` (`long[]`), and `shortArrayOf` (`short[]`). There is no `string[]`; a string is a `char[]`.
- There is no way to print an array like you would print a python `list`. Use something like [`array.forEach(::println)`](https://stackoverflow.com/questions/49899665/how-to-print-all-elements-of-string-array-in-kotlin-in-a-single-line) to achieve a similar effect, but each item will be on a different line.
- But you know what you *can* print in one line? `list`s, `map`s, and `set`s. `list`s are effectively tuples because they are not mutable.
- Sets and Lists print out in the same style: `[1, 2, 3]`, with square brackets.
- [Arrays are fixed-length. Lists may change in size later.](https://www.youtube.com/watch?v=ORsoHzgUFyQ)
- But wait, what the fuck is a `mutableList` then? (It's a list that is mutable, yes. But, at the same time, this seems to raise more questions about a java/kotlin developer's long-term mental health.)
- BUT WAIT. If you think that isn't complicated enough, there is more for you, you mastermind. I present to you: [the `ArrayList`](https://stackoverflow.com/a/64379829/1558430) (`arrayListOf`), a *mutable* data type that stores values in an `array`, but can also be resized. Also, fuck you.
- `::function` will reference the function without calling it. So functions aren't exactly first-class in terms of syntax. If you just `function`, it is not a silent statement; it is `Function invocation 'function()' expected`.
- Inline functions (`inline fun` vs just `fun`) are like lambdas, except they have a name. Use inline functions for [functions that accept another function or block of code](https://stackoverflow.com/a/44471411/1558430), where declaring a function as `inline` may occasionally speed up the function by not requiring a new function object to be declared within the callee. You should definitely look more into it.
- A `for` loop like `1..10` includes 10. To not include 10, use `1 until 10`.
- If a `for` loop is labelled (e.g. `outer@ for(i in 0..10)`), a `break@outer` will break that loop. This is useful for nested loops.
- Because of the unique way the Kotlin team is funded, to loop from 1 to 5, you write `for (i in 1..5)`, but if you want to loop from 5 to 1, you write `for(i in 5 downTo 1)`.
- There is no such thing as an `open data class`. That means [all data classes are final](https://dev.to/martinhaeusler/kotlin---the-good-the-bad-and-the-ugly-3jfo), and are not extendable or reusable in any way.
- `var foo: Type by Bar()` works through [delegating](https://kotlinlang.org/docs/delegated-properties.html#delegating-to-another-property) getting and setting that variable to a delegate class. A delegate is a class with `getValue()` and `setValue()` defined.
